---

title: "Migration MyCoRe LTS 2025.06 nach 2025.12"
mcr_version: ['2025.12']
author: []
description: "
      Diese Seite fasst Systemanforderungen für die Nutzung des MyCoRe LTS 2025.12 und die Migration von Version
      2025.06 zu 2025.12 zusammen.
    "
date: "2025-06-20"
---

    <div id="requirements_202512">
      <div class="alert alert-warning">
        Diese Seite ist <strong>Work in Progress</strong>. <br />
        Sie wird im Rahmen der Fertigstellung des aktuellen MyCoRe-Releases weiter ergänzt!
      </div>
  
      <h2>Systemanforderungen MyCoRe LTS 2025.12</h2>
      <p>
        Für den Betrieb einer MyCoRe-Anwendung unter LTS 2025.12 sind folgende Voraussetzungen zu erfüllen:
      </p>

      <h3>Betriebssystem</h3>
      <p>MyCoRe LTS 2025.12 ist auf diesen Betriebsystemen im Einsatz. Höhere Versionen sollten kein Problem darstellen.
      </p>
      <ul>
        <li>Open SuSE Leap 15.6 oder höher</li>
        <li>SuSE SLES 15.6 oder höher</li>
        <li>Ubuntu 24.04 LTS</li>
        <li>CentOS 8</li>
        <li>RHEL 8</li>
        <li>Windows 11 für Test- und Entwicklungssysteme</li>
      </ul>

      <h3>Standardsoftware</h3>
      <p>Zur Arbeit mit MyCoRe LTS 2025 sind folgende Softwarekomponenten erforderlich bzw. empfohlen. Diese sind alle
        von Drittanbietern und im Normalfall in den Distributionen enthalten.
      </p>
      <ul>
        <li>Java 21 (OpenJDK) (muss ggf. extern nachinstalliert werden)</li>
        <li>Tomcat 10.1.x bzw. Jetty 11.x (alternativ ein System mit Unterstützung von Servlet-6.0 und JakartaEE)</li>
        <li>SOLR 9.8.1 oder höher</li>
        <li>
          eine
          <a href="https://docs.jboss.org/hibernate/orm/6.5/javadocs/org/hibernate/dialect/package-summary.html">hibernate-fähige</a>
          relationale Datenbank wie PostgreSQL 16 oder höher , MySQL/Maria-DB 10 oder höher, DB2; für Testzwecke genügt auch die integrierte Datenbank H2
        </li>
        <li>Git 2.26 oder höher</li>
        <li>Apache Maven 3.6.3 oder höher</li>
      </ul>
      
      <h2>Neuerungen</h2>
      <strong>... die eine Migration erforderlich machen</strong>
      <h3>API-Anpassungen</h3>
      <ul>
        <li>Die Methode <code>MCRAccessControlSystem#instance()</code> wurde umbenannt (siehe unten).</li>
      </ul>
      <h3>Umstellung auf das normalisierte Datenmodell und den Object Expander</h3>
          Mit diesen Änderungen führt das MyCoRe-Framework ein neues, robusteres und performanteres System zur Handhabung von Objektmetadaten ein. Das Kernkonzept ist die Trennung zwischen normalisierten und expandierten Objekten.
          
          <h4>Normalisierte vs. Expandierte Objekte:</h4>
          <ul>
            <li>
              <strong>Normalisiertes Objekt (MCRObject):</strong> Dies ist die Form, in der Objekte jetzt in der Datenbank (XML-Store) gespeichert werden. Sie enthalten keine redundanten Informationen mehr. Insbesondere sind die Listen von Kindern (<code>&lt;children&gt;</code>) und Derivaten (<code>&lt;derobjects&gt;</code>) nicht mehr Teil der <code>MCRObjectStructure</code>. Diese Informationen werden nun zentral und konsistent über den <code>MCRLinkTableManager</code> verwaltet.
            </li>
            <li>
              <strong>Expandiertes Objekt (MCRExpandedObject):</strong> Dies ist eine angereicherte, denormalisierte In-Memory-Repräsentation eines Objekts. Sie wird zur Laufzeit für Anzeigezwecke (z. B. in XSLT-Transformationen), für die Indexierung (Solr) oder in APIs verwendet. Sie enthält die vollständigen Informationen, einschließlich Kinder, Derivate und von Eltern geerbte Metadaten.
            </li>
          </ul>
          <h4>Der MCRExpandedObjectManager und Caching</h4>
          <ul>
            <li>
              Der neue <code>MCRExpandedObjectManager</code> ist die zentrale Anlaufstelle, um ein expandiertes Objekt zu erhalten (<code>MCRExpandedObjectManager.getInstance().getExpandedObject(obj)</code>).
            </li>
            <li>
              Expandierte Objekte werden in einem Dateisystem-basierten Cache (<code>MCRExpandedObjectCache</code>) zwischengespeichert, um die Performance drastisch zu verbessern. Der Cache wird durch Event Handler automatisch invalidiert, wenn sich ein Objekt oder seine verknüpften Objekte ändern.
            </li>
          </ul>
          <h4>Event-basierte Aktualisierungen statt Metadata-Share-Agent:</h4>
          <ul>
            <li>
              Das alte <code>MCRMetadataShareAgent</code>-System zur Vererbung von Metadaten wurde vollständig entfernt.
            </li>
            <li>
              Die Aktualisierung von abhängigen Objekten (z.B. Kinder, wenn sich ein Elternteil ändert) erfolgt nun über neue Events wie <code>ANCESTOR_UPDATED</code> und <code>LINKED_UPDATED</code>.
            </li>
            <li>
              Diese Events führen zur Invalidierung des Caches für die betroffenen Objekte, die dann bei der nächsten Anforderung neu expandiert werden.
            </li>
          </ul>
          <h4>Normalisierungs- und Validierungs-Framework</h4>
          <ul>
            <li>
              Es wurde ein konfigurierbares Framework eingeführt, um Objekte vor dem Speichern zu normalisieren und zu validieren. Dies sorgt für eine höhere Datenkonsistenz. Normalizer entfernen z.B. automatisch generierte Klassifikationen oder leeren die <code>relatedItem</code>-Struktur in MODS-Objekten, bevor diese gespeichert werden.
            </li>
          </ul>

      <h2>Migrationsschritte</h2>
      <ul>
        <li>
          <p>
            <strong>API-Änderungen im Code beachten (Breaking Changes!)</strong><br/>
            Der meiste Anpassungsbedarf wird in Ihrem eigenen Code entstehen, der auf die MyCoRe-Datenstrukturen zugreift.
          </p>
          <strong>Zugriff auf Kinder und Derivate:</strong>
          <ul>
            <li>
              <strong>ALT:</strong> <code>mcrObject.getStructure().getChildren()</code> oder <code>mcrObject.getStructure().getDerivates()</code>
            </li>
            <li>
              <strong>NEU:</strong> Diese Methoden existieren auf <code>MCRObjectStructure</code> nicht mehr. Verwenden Sie stattdessen:
              <ul>
                <li>
                  Um die IDs zu erhalten (empfohlen und performant):
                  {{< highlight java "linenos=table">}}
List<MCRObjectID> childrenIDs = MCRMetadataManager.getChildren(mcrObject.getId());
List<MCRObjectID> derivateIDs = MCRMetadataManager.getDerivateIds(mcrObject.getId());
                  {{< /highlight >}}
                </li>
                <li>
                  Um die vollständigen Link-Objekte (<code>MCRMetaLinkID</code>) zu erhalten, verwenden Sie die statische Methode <code>MCRMetadataManager#retrieveMCRExpandedObject</code>, die die Daten aus dem Cache lädt:
                  {{< highlight java "linenos=table">}}
MCRExpandedObject expObject = MCRMetadataManager.retrieveMCRExpandedObject(mcrObject.getId());
List<MCRMetaLinkID> children = expObject.getStructure().getChildren();
List<MCRMetaEnrichedLinkID> derivates = expObject.getStructure().getDerivates();
                  {{< /highlight >}}
                </li>
                <li>
                  Alternativ kann der <code>MCRExpandedObjectManager</code> verwendet werden, wobei die Daten live ergänzt werden:
                  {{< highlight java "linenos=table">}}
MCRExpandedObject expObject = MCRExpandedObjectManager.getInstance().getExpandedObject(mcrObject);
List<MCRMetaLinkID> children = expObject.getStructure().getChildren();
List<MCRMetaEnrichedLinkID> derivates = expObject.getStructure().getDerivates();
                  {{< /highlight >}}
                </li>
              </ul>
            </li>
          </ul>
          <strong>MCRMetadataManager API-Vereinfachung:</strong>
          <ul>
            <li>
              Methoden mit Zeitstempel-basiertem Caching wurden entfernt.
            </li>
            <li>
              <strong>ALT:</strong> <code>MCRMetadataManager.getDerivateIds(objectId, 10, TimeUnit.SECONDS)</code>
            </li>
            <li>
              <strong>NEU:</strong> <code>MCRMetadataManager.getDerivateIds(objectId)</code>
            </li>
            <li>
              <strong>ALT:</strong> <code>MCRMetadataManager.getObjectId(derivateId, 10, TimeUnit.SECONDS)</code>
            </li>
            <li>
              <strong>NEU:</strong> <code>MCRMetadataManager.getObjectId(derivateId)</code>
            </li>
          </ul>
          <strong>MCRLinkTableManager:</strong>
          <ul>
            <li>
              Anstelle von String-Konstanten für Link-Typen (z.B. <code>parent</code>, <code>derivate</code>) wird nun das Enum <code>MCRLinkType</code> verwendet.
            </li>
            <li>
              <strong>ALT:</strong> <code>ltm.getSourceOf(id, "parent")</code>
            </li>
            <li>
              <strong>NEU:</strong> <code>ltm.getSourceOf(id, MCRLinkType.PARENT)</code>
            </li>
          </ul>
        </li>
        <li>
          <p>
            <strong>Datenmigration durchführen</strong><br/>
            Ihre bestehenden XML-Daten in der Datenbank enthalten noch die alten, nicht-normalisierten Strukturen (&lt;children&gt; und &lt;derobjects&gt;). Diese müssen migriert werden.
          </p>
          <strong>CLI-Befehl zur Migration:</strong><br/>
          Es wurde ein neuer CLI-Befehl eingeführt, um ein einzelnes Objekt zu migrieren:<br/>
          <code>migrate to normalized object {id}</code>
          <br/>
          <strong>Migrationsstrategie für Kind-Reihenfolge:</strong>
          <ul>
            <li>
              Der Migrationsbefehl entfernt die redundanten &lt;children&gt; und &lt;derobjects&gt; aus der XML-Struktur.
            </li>
            <li>
              Die alte &lt;children&gt;-Liste enthielt eine implizite Reihenfolge. Sie können steuern, ob diese erhalten bleiben soll, indem Sie eine Strategie festlegen:
              {{< highlight properties "linenos=table">}}
# Behält die Reihenfolge in einem neuen <childrenOrder>-Element.
# Gut, wenn die Reihenfolge wichtig war.
MCR.Migration.ChildrenOrder.Strategy=org.mycore.migration.strategy.MCRAlwaysAddChildrenOrderStrategy

# Standard: Entfernt die Kinderliste ohne sie zu überführen.
# Sicher, wenn die Reihenfolge nie eine Rolle gespielt hat.
# MCR.Migration.ChildrenOrder.Strategy=org.mycore.migration.strategy.MCRNeverAddChildrenOrderStrategy
              {{< /highlight >}}
            </li>
          </ul>
          <strong>Vorgehen:</strong>
          <ul>
            <li>
              Für eine vollständige Datenmigration müssen mehrere Kommandos ausgeführt werden:
              <ol>
                <li><code>select objects with xpath /mycoreobject</code> - um alle Objekte auszuwählen.</li>
                <li><code>execute for selected migrate to normalized object {x}</code> - um die Migration für jedes ausgewählte Objekt auszuführen.</li>
                <li><code>execute for selected repair metadata search of ID {x}</code> - um die Metadaten für jedes ausgewählte Objekt zu korrigieren.</li>
                <li><code>repair metadata search of type derivate</code> - um die Metadaten für alle Derivate zu korrigieren.</li>
              </ol>
            </li>
            <li>
              <strong>Wichtig:</strong> Führen Sie diesen Schritt erst aus, nachdem Sie Ihre Konfiguration und Ihren Code angepasst haben.
            </li>
          </ul>
        </li>
        <li>
          <p>
            Bei allen MyCoRe-Modulen wurden die Tests von JUnit 4 auf JUnit 5 umgestellt.
            Die Unterstützung für JUnit 4 wurde entfernt. Dementsprechend sind auch die Test-Basisklassen
            <code>MCRTestCase</code>, <code>MCRJPATestCase</code> und <code>MCRStoreTestCase</code> entfernt worden.
            Wer in eigenen Modulen JUnit 4 Test hat, muss diese entsprechend anpassen.
          </p>
          <ul>
            <li>
              Statt <code>MCRTestCase</code> zu erweitern, kann die Annotation <code>@MyCoReTest</code> verwendet werden.
            </li>
            <li>
              Statt <code>MCRJPATestCase</code> zu erweitern, kann zusätzlich zu <code>@MyCoReTest</code> die Annotation
              <code>@ExtendWith(MCRJPAExtension.class)</code> verwendet werden. Für einige Methoden der entfallenen Test-Basisklasse
              gibt es Ersatz in der Hilfsklasse <code>MCRJPATestHelper</code> (z.B. <code>beginTransaction</code> und
              <code>endTransaction</code>).
            </li>
            <li>
              Statt <code>MCRStoreTestCase</code> zu erweitern, kann je nach Funktionsbedarf zusätzlich zu <code>@MyCoReTest</code> die Annotation<br/>
              <code>@ExtendWith(MCRStoreExtension.class)</code> oder <code>@ExtendWith({MCRJPATestExtension, MCRStoreExtension.class})</code><br/>
              verwendet werden.
            </li>
          </ul>
          <br/>
          <p>
            Statt <code>getTestProperties()</code> zu überschreiben, kann mit <code>@MCRTestConfiguration</code>
            oder, wenn die Werte dynamisch sind, direkt mit <code>MCRConfiguration2#set</code> gearbeitet werden.
          </p>
          <p>
            Bestehende <code>setUp</code>- und <code>tearDown</code>-Methoden können erhalten bleiben, müssen aber als
            <code>static</code> markiert werden und mit <code>@BeforeAll</code> bzw. <code>@AfterAll</code> annotiert werden.
            Der Aufruf der jeweiligen Super-Methode sowie eine ggf. vorhandene <code>@Override</code>-Annotation können
            ersatzlos entfernt werden.
          </p>
          <p>
            Wer seine JUnit 4 Tests nicht während der Migration umstellen möchte, kann vorerst auch das neue Modul
            <code>mycore-junit4</code> einbinden und die Migration später durchführen. Mit diesem Modul bleiben die
            oben genannten Test-Basisklassen zunächst noch erhalten. Zudem muss JUnit 4 als Abhängigkeit erhalten bleiben.
            {{< highlight xml "linenos=table">}}
            <dependency>
              <groupId>org.mycore</groupId>
              <artifactId>mycore-junit4</artifactId>
              <scope>test</scope>
            </dependency>
            <dependency>
              <groupId>junit</groupId>
              <artifactId>junit</artifactId>
              <scope>test</scope>
            </dependency>
            {{< /highlight >}}
            Die Test-Basisklassen sind im neuen Modul <code>mycore-junit4</code> als <code>@Deprecated</code> markiert.
            Im eigenen Modul muss daher innerhalb von <code>&lt;properties&gt;</code> vorübergehend der Eintrag <code>&lt;maven.compiler.arg/&gt;</code>
            hinzugefügt werden. Dies überschreibt die Standardeinstellung von MyCoRe
            (<code>&lt;maven.compiler.arg/&gt;-Werror&lt;/maven.compiler.arg/&gt;</code>) und erlaubt damit die Verwendung von derart markiertem Code.
          </p>
          <p>
            Dieses Modul soll nur vorübergehend die Migration eigener Tests erleichtern wird mit dem nächsten Release von MyCoRe wieder entfernt.
          </p>
        </li>
        <li>
          <p>
            Die Unterstützung der indirekte Instanziierung von Event-Handlern wird mit dem nächsten Release von MyCoRe entfernt.
            Hierbei handelt es sich um eigene Implementierungen von <code>MCREventHandlerInitializer</code>
            im Kombination mit einer Konfigurationen der folgenden Art:
            {{< highlight xml "linenos=table">}}
            MCR.EventHandler.MCRObject.042.MyCustomMode
            MCR.EventHandler.MyCustomMode=my.custom.CustomEventHandlerInitializer
            {{< /highlight >}}
            Wer diesen Mechanismus bisher nutzt, sollte bereits mit diesem Release auf die direkte Instanziierung umstellen.
          </p>
        </li>
        <li>
          <p>
            Im Nachgang zu den Änderungen in 2025.06 wurde nun auch die Methode <code>MCRAccessControlSystem#instance()</code> in
            <code>MCRAccessControlSystem#getInstance()</code> umbenannt. Die alte Methode wurde als <code>@Deprecated</code> markiert.
            Eigener Code bleibt daher noch funktionsfähig, muss aber vor der Verwendung der nächsten MyCoRe-Version umgestellt werden.
          </p>
        </li>
      </ul>

    </div>
